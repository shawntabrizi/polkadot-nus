<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

  <title>Merklized Storage</title>
  <meta property="og:title" content="Merklized Storage" />
  <meta property="og:type" content="website" />
  <meta property="og:image" content="https://www.shawntabrizi.com/polkadot-nus//featured-slide.jpg" />
  <meta property="og:url" content="https://www.shawntabrizi.com/polkadot-nus/" />
  <link rel="icon" href="./../../assets/favicon.svg" />
  <link rel="shortcut icon" href="./../../assets/favicon.png" />
  <link rel="stylesheet" href="./../../dist/reset.css" />
  <link rel="stylesheet" href="./../../dist/reveal.css" />
  <link rel="stylesheet" href="./../.././assets/styles/PBA-theme.css" id="theme" />
  <link rel="stylesheet" href="./../../css/highlight/shades-of-purple.css" />

  <link rel="stylesheet" href="./../.././assets/styles/custom-classes.css" />

</head>

<body class="site">
  <header class="site-header">
    <!-- This logo is a link only on the watching server, not the production build -->
    <a href="https://www.shawntabrizi.com/polkadot-nus/">
      <img style="height: 2.5vw;" class="watermark-logo" src="./../../assets/img/pba-logo-white.svg" alt="PBA Logo">
    </a>
  </header>
  <main class="reveal">
    <article class="slides">
      <section  data-markdown><script type="text/template">

# Merklized Storage
</script></section><section  data-markdown><script type="text/template">
### Why is this topic important?

To understand the underlying structure which allows for "verifiable proofs" in Polkadot.

Merkle Tries.
</script></section><section  data-markdown><script type="text/template">
## Since Bitcoin...

<div class="grid grid-cols-2">

<div>

<img style="width: 600px;" src="./assets/bitcoin-merkle-tree.png">

</div>
<div>

<img style="width: 600px;" src="./assets/bitcoin-merkle-proof.png">

</div>
</div>
</script></section><section  data-markdown><script type="text/template">
### Merkle Tree

<div class="grid grid-cols-2">

<div>

<img style="width: 600px; filter: invert(1);" src="./assets/merkle-tree.svg">

</div>
<div class="text-small">

1. Collect all the data you want to place in the merkle tree structure.
1. Find the hash of each piece of data.
1. Take two hash nodes and hash them into a new hash node.
1. Repeat this process for the new nodes until there is a single hash.
1. The final hash is the merkle root hash.

</div>
</div>
</script></section><section  data-markdown><script type="text/template">
### Merkle Proof

<div class="grid grid-cols-2">

<div>

<img style="width: 600px; filter: invert(1);" src="./assets/merkle-proof.svg">

</div>
<div class="text-small">

- Blue: Data you need in the proof.
- White: Data you calculate via hashes.
	- Not needed in the proof!
- Black: Data implied by the Blue nodes.
	- Not needed in the proof!
- Pink: Merkle root hash
	- Not needed in the proof!
	- Must be recalculated by you.
	- Must be provided by a verifiable decentralized source.
	- Must match.

</div>
</div>
</script></section><section  data-markdown><script type="text/template">
### Patricia Trie

<div class="flex-container">
<div class="left-small">

<img src="../../assets/img/4-Substrate/patricia-trie.svg" />

</div>

<div class="right">

- Position in the tree defines the associated key.
- Space optimized for elements which share a prefix.

</div>
</div>
</script></section><section  data-markdown><script type="text/template">
### Merkle Trie

<img style="width: 1200px;" src="./assets/merkle-trie-fusion.png" />
</script></section><section  data-markdown><script type="text/template">
### Base 16

<div class="flex-container">
<div class="left">

<img src="../../assets/img/4-Substrate/base-16-labeled.svg" />

</div>

<div class="right">

- We will mostly show binary trees for simplicity.
- But everything scales up as you add more nodes.
- 16 is a nice choice because it is 1/2 of a byte (two hex characters)
  - one hex character is a "nibble"

</div>
</div>
</script></section><section  data-markdown><script type="text/template">
### Merkle Trie Complexity

<div class="text-center">

Reading, Writing, Proofs

</div>
</script></section><section  data-markdown><script type="text/template">
### Merkle Read

<div class="image-container">

<img src="../../assets/img/4-Substrate/merkle-read.svg" />

<div class="top-right">

- $O(\log{n})$ reads
- Not so great.

</div>
</div>
</script></section><section  data-markdown><script type="text/template">
### Merkle Write

<div class="image-container">

<img src="../../assets/img/4-Substrate/merkle-write.svg" />

<div class="top-right text-small">

- Very expensive for a database
- $O(\log{n})$ reads, hashes and writes

</div>

<div class="bottom-left black-box text-small">

1. Follow the trie path to the value: $O(\log{n})$ reads
2. Write the new value: 1 write
3. Calculate new hash: 1 hash
4. Repeat (2) + (3) up the trie path: $O(\log{n})$ times

</div>
</div>
</script></section><section  data-markdown><script type="text/template">
### Merkle Proof

<div class="image-container">

<img src="../../assets/img/4-Substrate/merkle-proof.svg" />

<div class="top-right text-small">

- $O(\log{n})$
- Great for light clients!
- Low bandwidth, low computation!

</div>

<div class="bottom-left black-box text-small">

1. Full Node: Follow the trie path to the value: $O(\log{n})$ reads.
1. Full Node: Upload data of trie nodes read.
1. Light Client: Download trie node data.
1. Light Client: Verify by hashing: $O(\log{n})$ hashes.

</div>
</div>

<aside class="notes"><ul>
<li>Message is that proof is just enough trie content (can be a bag of node or some ordered node that needs to be complete with hashing as in compact proof TODO should we make a slide for compact proof and generally proof serialization?) to build a subset/subpart of the full state trie.</li>
</ul>
<p>This incomplete trie will then be accessed and used identically as the full state trie, but if access is not part of the proof, then the action is not finishing: Proof Incomplete case.</p>
<p>Invalid proof are proof where the hashing don&#39;t match (can be see as multiple trie).</p>
<p>TODO Could have some schema with the full state, then the proof and then two query on the proof: one that access data available and one that fail because incomplete : Probably already exists in storage deep dive</p>
</aside></script></section><section  data-markdown><script type="text/template">
### Compact Proof

- Simple encoding to remove redundant information
- Trie node codec already strives for compact encoding
- Still hashes info is redundant
- Nodes are ordered to reflect the trie structure

<aside class="notes"><ul>
<li>trie node codec strives to make things compact</li>
</ul>
<p>So merkle hash is calculated over most compact number of bytes.</p>
<ul>
<li>Still hashes info is redundant.</li>
</ul>
<p>again in a three node V1 and V2 only tree, if proof is for V1 only, then the proof contains two nodes: root (a branch) and V1 (a leaf).
Then the encoding of root will contains two hashes V1 leaf hashes and V2 leaf hashes.
Obviously V1 leaf hashes can be calculated by hashing V1 leaf, so we can just remove it from the root node and gain 32 non compressable bytes.</p>
<ul>
<li>Nodes are ordered to reflect the trie structure</li>
</ul>
<p>by ordering in a given way we can deduce the child parent relationship of nodes.
This can be done in multiple way, for instance encode in the trie node iteration: root -&gt; V1 then when decoding stack root and when unstack complete with V1 hash.
or the other way V1 -&gt; root (here the building need to stack root), then when decoding V1 then root.
Most/all trie algo are about keeping a stack of node (when more memory is used there is something wrong (~ 1 or two nodes)).</p>
</aside></script></section><section  data-markdown><script type="text/template">
### Proof Recorder

- Tool used to create proofs for transactions
- Simple footprint of all trie nodes accessed
- Then re-encoded (compact proof)

<aside class="notes"><p>Another message to convey is that producing proof is really only recording all access made during some actions (key access, value insert, value change, trie iteration...).
Any kind of changes work.
-&gt; write is a bit tricky in the sense it only read access and in memory changes. eg three node trie with V1 and V2 and a parent node, inserting V3 can just be adding a sibling to V1 and V2, but V3 will not be in proof, just the parent node.</p>
<p>This could be extended by the idea that key value caching should be disable for the first action otherwise trie node would not be access and we would not register proof correctly.
-&gt; can extend to Basti pr where there is two kind of cache: trie node level cache that is safe to use and key value cache that
Not sure it is worth going to far on cache strategy, but may be relevant to mention that by its structure trie node cache is shared between block.</p>
</aside></script></section><section  data-markdown><script type="text/template">
### Storage and proof size.

- Base 16 trie good for disk storage and requires less hashing.
- Binary trie proof footprint is smaller and uses less bandwidth.

<div class="flex-container">
<div class="left" style="margin: 20px;">

<img src="../../assets/img/4-Substrate/base-16.svg" />

</div>
<div class="right" style="margin: 20px;">

<img src="../../assets/img/4-Substrate/base-2.svg" />

</div>
</div>

<aside class="notes"><p>The trie structure (hexary) is mostly related to the storage model and do not produce the more compact proofs. One direction would be to decorelate storage from merklization. eg hexary node in storage but merklization over binary node. But the model get more complex.</p>
<p>A final message to it should be that (eth see it), the storage model is still not the most efficient: we use merkle trie index to access node that are stored under a btree index (rocksdb), a true state db would have it&#39;s inner indexing directly using the merkle structure.
Paritydb in this sense in a good middle ground as it implement a hash map access directly so the merkle trie index is over a hash map rather than a btree map: that is a huge gain.</p>
<p>What works in memory as simple data structure, also work as a db over disk and also extend to being merklized. Usually things can be mapped or referred to rather naturally. For instance an optimization of radix trie is not storing the full merkle path in each node and get the key with the value: this work in memory (not a huge gain), this work on disk (huge gain as you can have fix len node which is big gain for disk access), can work with merkle proof (but tricky if codec still store the full partial key).</p>
</aside></script></section><section  data-markdown><script type="text/template">
### Pruning

<div class="image-container">

<img src="../../assets/img/4-Substrate/pruning-1.svg" />

<div class="top-right" style="width: 40%">

- For holding older block states, and then cleaning up.
- Let’s update two values in this trie.

</div>
</div>
</script></section><section  data-markdown><script type="text/template">
### Pruning

<div class="image-container">

<img src="../../assets/img/4-Substrate/pruning-2.svg" />

<div class="top-right" style="width: 40%">

- We create new database entries, but keep the old ones too!

</div>
</div>
</script></section><section  data-markdown><script type="text/template">
### Pruning

<img src="../../assets/img/4-Substrate/pruning-3.svg" />
</script></section><section  data-markdown><script type="text/template">
### Pruning

<div class="image-container">

<img src="../../assets/img/4-Substrate/pruning-4.svg" />

<div class="top-left" style="width: 30%">

- Eventually, we prune the old data.

</div>
</div>
</script></section><section  data-markdown><script type="text/template">
### Real World Implementation

A merkle trie library is applied on top of a regular key/value database.

To understand how to parse the data in the database, you need to understand two different keys:

<br>
<div class="text-center">

1. Merkle Trie Key Path
2. Key Value Database Key Hash

</div>
</script></section><section  data-markdown><script type="text/template">
### What You Will See

<img src="../../assets/img/4-Substrate/navigate-storage-toc.svg" />
</script></section><section  data-markdown><script type="text/template">
### Navigating Substrate Storage

<img src="../../assets/img/4-Substrate/navigate-storage-1.svg" />
</script></section><section  data-markdown><script type="text/template">
### Navigating Substrate Storage

<img src="../../assets/img/4-Substrate/navigate-storage-2.svg" />
</script></section><section  data-markdown><script type="text/template">
### Navigating Substrate Storage

<img src="../../assets/img/4-Substrate/navigate-storage-3.svg" />
</script></section><section  data-markdown><script type="text/template">
### Navigating Substrate Storage

<img src="../../assets/img/4-Substrate/navigate-storage-4.svg" />
</script></section><section  data-markdown><script type="text/template">
### Navigating Substrate Storage

<img src="../../assets/img/4-Substrate/navigate-storage-5.svg" />
</script></section><section  data-markdown><script type="text/template">
### Navigating Substrate Storage

<img src="../../assets/img/4-Substrate/navigate-storage-6.svg" />
</script></section><section  data-markdown><script type="text/template">
### Navigating Substrate Storage

<img src="../../assets/img/4-Substrate/navigate-storage-7.svg" />
</script></section><section  data-markdown><script type="text/template">
### What You Just Saw

<div class="flex-container">
<div class="left">

<div>

<img src="../../assets/img/4-Substrate/patricia-trie-path.svg" style="width: 400px" />

</div>

<br>

Patricia provides the **trie path**.

</div>
<div class="right">

<div>

<img src="../../assets/img/4-Substrate/merkle-path.svg" style="width: 400px" />

</div>

<br>

Merkle provides the recursive **hashing** of children nodes into the parent.

</div>
</div>
</script></section><section  data-markdown><script type="text/template">
<!-- .slide: data-background-color="#4A2439" -->

# Questions
</script></section>
    </article>
  </main>

  <script src="./../../dist/reveal.js"></script>

  <script src="./../../plugin/markdown/markdown.js"></script>
  <script src="./../../plugin/highlight/highlight.js"></script>
  <script src="./../../plugin/zoom/zoom.js"></script>
  <script src="./../../plugin/notes/notes.js"></script>
  <script src="./../../plugin/math/math.js"></script>

  <script src="./../../assets/plugin/mermaid.js"></script>
  <script src="./../../assets/plugin/mermaid-theme.js"></script>

  <script src="./../../assets/plugin/chart/chart.js"></script>
  <script src="./../../assets/plugin/chart/chart.min.js"></script>

  <script src="./../../assets/plugin/tailwindcss.min.js"></script>

  <script>
    function extend() {
      var target = {};
      for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (source.hasOwnProperty(key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    }

    // default options to init reveal.js
    var defaultOptions = {
      controls: true,
      progress: true,
      history: true,
      center: true,
      transition: 'default', // none/fade/slide/convex/concave/zoom
      slideNumber: true,
      mermaid: {
        startOnLoad: false,
        logLevel: 3,
        theme: 'base',
        themeVariables: {
          primaryColor: purple,
          primaryTextColor: white,
          primaryBorderColor: pink,
          lineColor: pink,
          secondaryColor: lightPurple,
          tertiaryColor: lightPurple,
        },
      },
      chart: {
        defaults: {
          color: 'lightgray', // color of labels
          scale: {
            beginAtZero: true,
            ticks: { stepSize: 1 },
            grid: { color: "lightgray" }, // color of grid lines
          },
        },
        line: { borderColor: ["#ccc", "#E6007A", "#6D3AEE"], "borderDash": [[5, 10], [0, 0]] },
        bar: { backgroundColor: ["#ccc", "#E6007A", "#6D3AEE"] },
      },
      plugins: [
        RevealMarkdown,
        RevealHighlight,
        RevealZoom,
        RevealNotes,
        RevealMath,
        RevealMermaid,
        RevealChart
      ]
    };

    // options from URL query string
    var queryOptions = Reveal().getQueryHash() || {};

    var options = extend(defaultOptions, {"width":1400,"height":900,"margin":0,"minScale":0.2,"maxScale":2,"transition":"none","controls":true,"progress":true,"center":true,"slideNumber":true,"backgroundTransition":"fade"}, queryOptions);
  </script>


  <script>
    Reveal.initialize(options);
  </script>
</body>

</html>
